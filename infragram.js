// Generated by CoffeeScript 1.6.3
var colormap, createContext, download, drawScene, generateShader, greyscale, handleLoadedTexture, img_context, initBuffers, initShaders, initTexture, map_context, mode, setGreyscale, setMode, setSlider, slider;

img_context = null;

map_context = null;

mode = "raw";

greyscale = true;

colormap = false;

slider = 1.0;

initBuffers = function(ctx) {
  var gl, textureCoords, vertices;
  gl = ctx.gl;
  ctx.vertexBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, ctx.vertexBuffer);
  vertices = [-1.0, -1.0, 1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0];
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
  ctx.vertexBuffer.itemSize = 2;
  ctx.textureBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, ctx.textureBuffer);
  textureCoords = [0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0];
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoords), gl.STATIC_DRAW);
  return ctx.textureBuffer.itemSize = 2;
};

createContext = function(canvasName) {
  var ctx;
  ctx = new Object();
  ctx.canvas = document.getElementById(canvasName);
  ctx.gl = getWebGLContext(ctx.canvas);
  initBuffers(ctx);
  return ctx;
};

initShaders = function(ctx) {
  var gl;
  gl = ctx.gl;
  ctx.shaderProgram = createProgramFromScripts(gl, ["shader-vs", "shader-fs"]);
  gl.useProgram(ctx.shaderProgram);
  ctx.shaderProgram.vertexPositionAttribute = gl.getAttribLocation(ctx.shaderProgram, "aVertexPosition");
  gl.enableVertexAttribArray(ctx.shaderProgram.vertexPositionAttribute);
  ctx.shaderProgram.textureCoordAttribute = gl.getAttribLocation(ctx.shaderProgram, "aTextureCoord");
  return gl.enableVertexAttribArray(ctx.shaderProgram.textureCoordAttribute);
};

drawScene = function(ctx, returnImage) {
  var gl, pColormap, pGreyscaleUniform, pHsvUniform, pNdviUniform, pSliderUniform;
  gl = ctx.gl;
  gl.bindBuffer(gl.ARRAY_BUFFER, ctx.vertexBuffer);
  gl.vertexAttribPointer(ctx.shaderProgram.vertexPositionAttribute, ctx.vertexBuffer.itemSize, gl.FLOAT, false, 0, 0);
  gl.bindBuffer(gl.ARRAY_BUFFER, ctx.textureBuffer);
  gl.vertexAttribPointer(ctx.shaderProgram.textureCoordAttribute, ctx.textureBuffer.itemSize, gl.FLOAT, false, 0, 0);
  pSliderUniform = gl.getUniformLocation(ctx.shaderProgram, "uSlider");
  gl.uniform1f(pSliderUniform, slider);
  pNdviUniform = gl.getUniformLocation(ctx.shaderProgram, "uNdvi");
  gl.uniform1f(pNdviUniform, (mode === "ndvi" ? 1.0 : 0.0));
  pGreyscaleUniform = gl.getUniformLocation(ctx.shaderProgram, "uGreyscale");
  gl.uniform1f(pGreyscaleUniform, (greyscale ? 1.0 : 0.0));
  pHsvUniform = gl.getUniformLocation(ctx.shaderProgram, "uHsv");
  gl.uniform1f(pHsvUniform, (mode === "hsv" ? 1.0 : 0.0));
  pColormap = gl.getUniformLocation(ctx.shaderProgram, "uColormap");
  gl.uniform1f(pColormap, (colormap ? 1.0 : 0.0));
  gl.drawArrays(gl.TRIANGLES, 0, 6);
  if (returnImage) {
    return ctx.canvas.toDataURL("image/png");
  }
};

generateShader = function(ctx, r, g, b) {
  r = r.toLowerCase().replace(/h/g, "r").replace(/s/g, "g").replace(/v/g, "b");
  g = g.toLowerCase().replace(/h/g, "r").replace(/s/g, "g").replace(/v/g, "b");
  b = b.toLowerCase().replace(/h/g, "r").replace(/s/g, "g").replace(/v/g, "b");
  r = r.replace(/[^xrgb\/\-\+\*\(\)\.0-9]*/g, "");
  g = g.replace(/[^xrgb\/\-\+\*\(\)\.0-9]*/g, "");
  b = b.replace(/[^xrgb\/\-\+\*\(\)\.0-9]*/g, "");
  r = r.replace(/([0-9])([^\.])?/g, "$1.0$2");
  g = g.replace(/([0-9])([^\.])?/g, "$1.0$2");
  b = b.replace(/([0-9])([^\.])?/g, "$1.0$2");
  if (r === "") {
    r = "r";
  }
  if (g === "") {
    g = "g";
  }
  if (b === "") {
    b = "b";
  }
  document.getElementById("shader-fs").text = "        precision mediump float;        varying vec2 vTextureCoord;        uniform sampler2D uSampler;        uniform float uSlider;        uniform float uNdvi;        uniform float uGreyscale;        uniform float uHsv;        uniform float uColormap;        vec4 greyscale_colormap(float n)        {            vec3 x  = vec3(0.0, 1.0, 0.0);            vec3 y0 = vec3(0.0, 0.0, 0.0);            vec3 y1 = vec3(255.0, 255.0, 255.0) / 255.0;            return vec4(                (n - x[0]) / (x[1] - x[0]) * (y1[0] - y0[0]) + y0[0],                (n - x[0]) / (x[1] - x[0]) * (y1[1] - y0[1]) + y0[1],                (n - x[0]) / (x[1] - x[0]) * (y1[2] - y0[2]) + y0[2],                1.0);        }        vec4 color_colormap(float n)        {            vec3 x = vec3(0.0, 0.5, 0.0);            vec3 y0 = vec3(25.0, 0.0, 175.0) / 255.0;            vec3 y1 = vec3(38.0, 195.0, 195.0) / 255.0;            if (n >= 0.5)            {                x = vec3(0.5, 0.75, 0.0);                y0 = vec3(50.0, 155.0, 60.0) / 255.0;                y1 = vec3(195.0, 190.0, 90.0) / 255.0;            }            else if (n >= 0.75)            {                x = vec3(0.75, 1.0, 0.0);                y0 = vec3(195.0, 190.0, 90.0) / 255.0;                y1 = vec3(185.0, 50.0, 50.0) / 255.0;            }            return vec4(                (n - x[0]) / (x[1] - x[0]) * (y1[0] - y0[0]) + y0[0],                (n - x[0]) / (x[1] - x[0]) * (y1[1] - y0[1]) + y0[1],                (n - x[0]) / (x[1] - x[0]) * (y1[2] - y0[2]) + y0[2],                1.0);        }        vec4 rgb2hsv(vec4 c)        {            vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);            vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));            vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));            float d = q.x - min(q.w, q.y);            float e = 1.0e-10;            return vec4(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x, 1.0);        }        vec4 hsv2rgb(vec4 c)        {            vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);            vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);            return vec4(c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y), 1.0);        }        void main(void)        {            vec4 color = texture2D(uSampler, vTextureCoord);            if (uColormap >= 1.0)            {                color = vec4(vTextureCoord, 0.0, 0.0);            }            else if (uHsv >= 1.0)            {                color = rgb2hsv(color);            }            float x = uSlider;            float r = color.r;            float g = color.g;            float b = color.b;" + "float rr = " + r + ";" + "float gg = " + g + ";" + "float bb = " + b + ";" + "if (uNdvi < 1.0)            {                color = vec4(rr, gg, bb, 1.0);                gl_FragColor = (uHsv < 1.0) ? color : hsv2rgb(color);            }            else            {                gl_FragColor = (uGreyscale < 1.0) ? color_colormap(rr) : greyscale_colormap(rr);            }        }";
  return initShaders(ctx);
};

download = function(ctx) {
  var event, lnk;
  lnk = document.createElement("a");
  lnk.download = (new Date()).toISOString().replace(":", "_") + ".png";
  lnk.href = drawScene(ctx, true);
  if (document.createEvent) {
    event = document.createEvent("MouseEvents");
    event.initMouseEvent("click", true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
    return lnk.dispatchEvent(event);
  } else if (lnk.fireEvent) {
    return lnk.fireEvent("onclick");
  }
};

setGreyscale = function(value) {
  return greyscale = value;
};

setSlider = function(value) {
  return slider = value;
};

setMode = function(newMode) {
  mode = newMode;
  $("#download").show();
  if (mode === "ndvi") {
    $("#colorbar-container")[0].style.display = "inline-block";
    return $("#colormaps-group")[0].style.display = "inline-block";
  } else {
    $("#colorbar-container")[0].style.display = "none";
    return $("#colormaps-group")[0].style.display = "none";
  }
};

handleLoadedTexture = function(ctx) {
  var gl;
  gl = ctx.gl;
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, ctx.texture);
  gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, ctx.image);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
  setMode("raw");
  generateShader(ctx, "r", "g", "b");
  return drawScene(ctx);
};

initTexture = function(ctx, fileObject) {
  ctx.texture = ctx.gl.createTexture();
  ctx.image = new Image();
  ctx.image.onload = function() {
    return handleLoadedTexture(ctx);
  };
  return ctx.image.src = fileObject;
};

$("document").ready(function() {
  img_context = createContext("canvas-image");
  map_context = createContext("colorbar");
  $("#file-sel").change(function() {
    var reader;
    if (this.files && this.files[0]) {
      reader = new FileReader();
      reader.onload = function(eventObject) {
        return initTexture(img_context, eventObject.target.result);
      };
      return reader.readAsDataURL(this.files[0]);
    }
  });
  $('button#raw').click(function() {
    setMode("raw");
    generateShader(img_context, "r", "g", "b");
    return drawScene(img_context);
  });
  $('button#ndvi').click(function() {
    setMode("ndvi");
    generateShader(img_context, "(((r-b)/(r+b))+1)/2", "(((r-b)/(r+b))+1)/2", "(((r-b)/(r+b))+1)/2");
    return drawScene(img_context);
  });
  $('button#nir').click(function() {
    setMode("nir");
    generateShader(img_context, "r", "r", "r");
    return drawScene(img_context);
  });
  $('#download').click(function() {
    return download(img_context);
  });
  $('#infragrammar_hsv').submit(function(event) {
    setMode("hsv");
    generateShader(img_context, $('#h_exp').val(), $('#s_exp').val(), $('#v_exp').val());
    return drawScene(img_context);
  });
  $('#infragrammar').submit(function(event) {
    setMode("rgb");
    generateShader(img_context, $('#r_exp').val(), $('#g_exp').val(), $('#b_exp').val());
    return drawScene(img_context);
  });
  $('#infragrammar_mono').submit(function(event) {
    setMode("mono");
    generateShader(img_context, $('#m_exp').val(), $('#m_exp').val(), $('#m_exp').val());
    return drawScene(img_context);
  });
  $('button#grey').click(function() {
    setGreyscale(true);
    return drawScene(img_context);
  });
  $('button#color').click(function() {
    setGreyscale(false);
    return drawScene(img_context);
  });
  return $('#slider').slider().on('slide', function(event) {
    setSlider(event.value / 100.0);
    return drawScene(img_context);
  });
});
