// Generated by CoffeeScript 1.6.3
var canvas, download, drawScene, gl, greyscale, handleLoadedTexture, initBuffers, initShaders, initTexture, mode, onFileSelect, setGreyscale, setMode, shaderProgram, texture, textureBuffer, vertexBuffer, webGlStart;

canvas = null;

gl = null;

shaderProgram = null;

vertexBuffer = null;

textureBuffer = null;

texture = null;

mode = "raw";

greyscale = true;

initShaders = function() {
  shaderProgram = createProgramFromScripts(gl, ["shader-vs", "shader-fs"]);
  gl.useProgram(shaderProgram);
  shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
  gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);
  shaderProgram.textureCoordAttribute = gl.getAttribLocation(shaderProgram, "aTextureCoord");
  gl.enableVertexAttribArray(shaderProgram.textureCoordAttribute);
  shaderProgram.pGreyscaleUniform = gl.getUniformLocation(shaderProgram, "uGreyscale");
  return shaderProgram.pModeUniform = gl.getUniformLocation(shaderProgram, "uMode");
};

initBuffers = function() {
  var textureCoords, vertices;
  vertexBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
  vertices = [-1.0, -1.0, 1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0];
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
  vertexBuffer.itemSize = 2;
  textureBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, textureBuffer);
  textureCoords = [0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0];
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoords), gl.STATIC_DRAW);
  return textureBuffer.itemSize = 2;
};

handleLoadedTexture = function(texture) {
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.image);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
  gl.bindTexture(gl.TEXTURE_2D, null);
  return drawScene(false);
};

initTexture = function(fileObject) {
  texture = gl.createTexture();
  if (!texture) {
    alert("Failed to create square buffer");
  }
  if (texture) {
    texture.image = new Image();
    if (!texture.image) {
      alert("Failed to create image");
    }
  }
  if (texture && texture.image) {
    texture.image.onload = function() {
      return handleLoadedTexture(texture);
    };
    return texture.image.src = fileObject;
  }
};

drawScene = function(returnImage) {
  gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
  gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, vertexBuffer.itemSize, gl.FLOAT, false, 0, 0);
  gl.bindBuffer(gl.ARRAY_BUFFER, textureBuffer);
  gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, textureBuffer.itemSize, gl.FLOAT, false, 0, 0);
  switch (mode) {
    case "ndvi":
      gl.uniform1f(shaderProgram.pModeUniform, 1.0);
      break;
    case "nir":
      gl.uniform1f(shaderProgram.pModeUniform, 2.0);
      break;
    default:
      gl.uniform1f(shaderProgram.pModeUniform, 0.0);
  }
  if (greyscale) {
    gl.uniform1f(shaderProgram.pGreyscaleUniform, 1.0);
  } else {
    gl.uniform1f(shaderProgram.pGreyscaleUniform, 0.0);
  }
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.drawArrays(gl.TRIANGLES, 0, 6);
  if (returnImage) {
    return canvas.toDataURL("image/png");
  }
};

webGlStart = function() {
  canvas = document.getElementById("canvas-image");
  gl = getWebGLContext(canvas);
  if (gl) {
    initShaders();
    return initBuffers();
  }
};

download = function() {
  var event, lnk;
  lnk = document.createElement("a");
  lnk.download = (new Date()).toISOString().replace(":", "_") + ".png";
  lnk.href = drawScene(true);
  if (document.createEvent) {
    event = document.createEvent("MouseEvents");
    event.initMouseEvent("click", true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
    return lnk.dispatchEvent(event);
  } else if (lnk.fireEvent) {
    return lnk.fireEvent("onclick");
  }
};

setGreyscale = function(value) {
  greyscale = value;
  drawScene();
  return $("#download").show();
};

setMode = function(newMode) {
  mode = newMode;
  drawScene();
  $("#download").show();
  if (mode === "ndvi") {
    return $("#colormaps-group")[0].style.display = "inline-block";
  } else {
    return $("#colormaps-group")[0].style.display = "none";
  }
};

onFileSelect = function() {
  var input, reader;
  input = document.getElementById("file-sel");
  if (input.files && input.files[0]) {
    reader = new FileReader();
    reader.onload = function(e) {
      initTexture(e.target.result);
      return $("#download").show();
    };
    return reader.readAsDataURL(input.files[0]);
  }
};
